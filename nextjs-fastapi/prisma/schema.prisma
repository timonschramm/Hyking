generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider  = "postgresql"
  url       = env("DATABASE_URL")
  directUrl = env("DIRECT_URL")
}

model Activity {
  id                      Int      @id @default(autoincrement())
  title                   String
  teaserText              String
  descriptionShort        String
  descriptionLong         String
  categoryId              Int
  difficulty              Int
  landscapeRating         Int
  experienceRating        Int
  staminaRating           Int
  length                  Float
  ascent                  Float
  descent                 Float
  durationMin             Float
  minAltitude             Float
  maxAltitude             Float
  pointLat                Float
  pointLon                Float
  isWinter                Boolean
  isClosed                Boolean
  primaryRegion           String
  primaryImageId          String
  publicTransportFriendly Boolean
  category                Category @relation(fields: [categoryId], references: [id])
  images                  Image[]
  seasons                 Season[]
  swipes                 ActivitySwipe[]
}

model Category {
  id         Int        @id @default(autoincrement())
  name       String
  activities Activity[]
}

model Season {
  id         Int      @id @default(autoincrement())
  activityId Int
  month      String
  isActive   Boolean
  activity   Activity @relation(fields: [activityId], references: [id])
}

model Image {
  id         Int      @id @default(autoincrement())
  activityId Int
  imageId    String
  activity   Activity @relation(fields: [activityId], references: [id])
}

model Profile {
  id                  String             @id @default(cuid())
  email               String
  age                 Int?
  imageUrl            String?
  gender              String?
  location            String?
  experienceLevel     ExperienceLevel?
  preferredPace       PreferredPace?
  preferredDistance   PreferredDistance?
  dogFriendly         Boolean?
  transportation      Transportation?
  spotifyConnected    Boolean            @default(false)
  spotifyAccessToken  String?
  spotifyRefreshToken String?
  spotifyTokenExpiry  DateTime?
  onboardingCompleted Boolean            @default(false)
  artists             UserArtist[]
  interests           UserInterest[]
  sentSwipes          UserSwipe[]        @relation("SwipeSender") // Swipes they've sent to others
  receivedSwipes      UserSwipe[]        @relation("SwipeReceiver") // Swipes they've received
  matches             Match[]            @relation("UserMatches") // Their matches
  bio                 String?
  activitySwipes     ActivitySwipe[]
}

model UserSwipe {
    id            String    @id @default(cuid())
    senderId      String
    receiverId    String
    action        String    // 'like' or 'dislike'
    timestamp     DateTime  @default(now())
    sender        Profile   @relation("SwipeSender", fields: [senderId], references: [id], onDelete: Cascade)
    receiver      Profile   @relation("SwipeReceiver", fields: [receiverId], references: [id], onDelete: Cascade)
    isViewed      Boolean   @default(false)  // For tracking if the receiver has seen this like

    @@unique([senderId, receiverId])
}

model Match {
    id            String    @id @default(cuid())
    users         Profile[] @relation("UserMatches")
    createdAt     DateTime  @default(now())
    lastActivity  DateTime  @default(now())
    // messages      Message[]
    isActive      Boolean   @default(true)
      // Optional: planned activity for the match
    // plannedActivityId Int?
    // plannedActivity   Activity? @relation(fields: [plannedActivityId], references: [id])
}



model Artist {
  id        String       @id @default(cuid())
  spotifyId String       @unique
  name      String
  imageUrl  String?
  createdAt DateTime     @default(now())
  updatedAt DateTime     @updatedAt
  profiles  UserArtist[]
  genres    Genre[]      @relation("ArtistGenres")
}

model Genre {
  id      String   @id @default(uuid())
  name    String   @unique
  artists Artist[] @relation("ArtistGenres")
}

model UserArtist {
  id        String   @id @default(cuid())
  profileId String
  artistId  String
  hidden    Boolean  @default(false)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  artist    Artist   @relation(fields: [artistId], references: [id], onDelete: Cascade)
  profile   Profile  @relation(fields: [profileId], references: [id], onDelete: Cascade)

  @@unique([profileId, artistId])
}

enum Month {
  jan
  feb
  mar
  apr
  may
  jun
  jul
  aug
  sep
  oct
  nov
  dec
}

enum InterestCategory {
  SELF_CARE
  SPORTS
  CREATIVITY
  GOING_OUT
  STAYING_IN
}

model Interest {
  id        String           @id @default(cuid())
  name      String           @unique
  category  InterestCategory
  users     UserInterest[]
  createdAt DateTime         @default(now())
  updatedAt DateTime         @updatedAt
}



model UserInterest {
  id         String   @id @default(cuid())
  profileId  String
  interestId String
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt

  profile  Profile  @relation(fields: [profileId], references: [id], onDelete: Cascade)
  interest Interest @relation(fields: [interestId], references: [id], onDelete: Cascade)

  @@unique([profileId, interestId])
}

enum ExperienceLevel {
  BEGINNER
  INTERMEDIATE
  ADVANCED
  EXPERT
}

enum PreferredPace {
  LEISURELY
  MODERATE
  FAST
  VERY_FAST
}

enum PreferredDistance {
  SHORT
  MEDIUM
  LONG
  VERY_LONG
}

enum Transportation {
  CAR
  PUBLIC_TRANSPORT
  BOTH
}

model ActivitySwipe {
  id         String   @id @default(cuid())
  userId     String
  activityId Int
  action     String   // 'like' or 'dislike'
  timestamp  DateTime @default(now())
  user       Profile  @relation(fields: [userId], references: [id], onDelete: Cascade)
  activity   Activity @relation(fields: [activityId], references: [id], onDelete: Cascade)

  @@unique([userId, activityId])
}
